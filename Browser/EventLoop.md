# EventLoop & CallBack Function

## EventLoop & Single Thread(이벤트루프와 싱글 스레드)

자바스크립트는 **Single Thread 기반**이다. EventLoop가 Single Thread를 기반으로 한 구조이기 때문이다.

**그럼 이 EventLoop은 무엇일까?**
<br>

## 자료구조

Stack과 Queue의 구조를 어느 정도는 알고 있다는 전제하에 진행하면. 

> 추후 Stack(스택)과 Queue(큐) 추가예정.

간단하게 Stack은 `LIFO`이며 큐는 `FIFO`이다. Stack은 컵 모양의 공간에 넣고 빼는 것이며 Queue는 양쪽이 뚫려있는 튜브 모양을 생각하면 된다.

위의 2개의 자료구조는 자바스크립트에서 호출 **스택**(Call Stack)과 태스크 **큐**(Task Queue)로 사용이 되고 있다.

> [호출 스택에 대해서 먼저 알아보기](https://github.com/SeonHyungJo/FrontEnd-Dev/blob/master/Javascript/Basic_1_CallStack.md)

Stack은 여러 곳에서 사용이 되는 구조이다. Stack을 쉽게 생각하면 `[main(), a(), b()]` 순서로 호출하면 `b -> a -> main` 순서로 빠져나오게 된다. 그러면 자바스크립트의 기본 내장되어있는 대표 비동기 동작을 하게 해주는 `setTimeout()`에 대해 살펴보자.

```js
function foo() {
    console.log("b");
}

console.log("a");

setTimeout(foo, 0);

console.log("c");
```

위와 같은 코드를 실행하게 되면 출력 결과는 `a -> c -> b`가 된다. 의사 코드로 소스를 분석해보면.

1. a를 출력해라
2. 0초 뒤에 foo를 실행해라
3. c를 출력해라

위에서 언급한 호출 스택에 따르면 먼저 들어온 것을 끝내야 다음 것을 끝낼 수 있다. 그렇다면 순서는 `a -> b -> c`가 되어야 하지 않나? 라는 생각을 할 수 있다. 호출 스택에서는 앞의 내용이 맞지만, 자바스크립트에서 비동기 호출은 추가적으로 알아야 하는 것이 있다. 자바스크립트는 호출 스택만 사용하지 않기 때문이다.

![이벤트루프](https://user-images.githubusercontent.com/24274424/59566325-ab4f2e80-9099-11e9-86f8-4eda4add1318.png)

기본 구조는 위의 사진과 같다. 위와 같은 구조를 생각하면서 코드를 라인 단위로 살펴보면

1. `main()` 스택에 들어감
2. `log("a")` 도 스택에 들어간 뒤 실행
3. `setTimeout()`이 스택에 들어간 뒤 실행 - 백그라운드에서 0초 뒤에 foo를 "실행"시키라고 명령
4. 0초가 지나 "태스크 큐"에 `foo()` 들어감
5. `log("c")` 가 스택에 들어간 뒤 실행
6. `main()` 종료
7. 태스크 큐에 있던 `foo()`를 호출 스택에 밀어 넣음 (이벤트 루프가 전역 컨텍스트의 main이 종료되면 큐 실행)
8. `foo()`가 호출 스택에 들어간 뒤 실행

위와 같은 순서로 실행이 되어 `a -> c -> b`와 같은 순서로 찍히는 것이다.
<br>

## CallBack Function(콜백 함수)

자바스크립트의 싱글 쓰레드 구조에서 비동기의 이벤트 기반 실행이나 AJAX 요청이 필요하다면 콜백 함수를 이용해 백그라운드로 보내 큐를 통해 호출 스택으로 보내 해결한다.

자바스크립트에서는 쓰레드를 통해 병렬처리가 안 되기 때문에 콜백 함수의 사용은 당연하다.
<br>

## Queue & CallBack(큐와 콜백)

이벤트 루프의 가장 중요한 곳은 위 과정의 3번, 4번, 7번이다. 흔히 `setTimeout(foo, 3)` 함수를 실행하면 **`foo` 함수를 3초 뒤에 실행시켜라** 라고 생각한다. 그러나 4번에서 보이듯이 foo는 일정 시간 뒤에 실행되는 게 아니라 **3초 뒤에 큐에 들어간다.**

큐에 들어간 foo는 호출 스택에 진행되는 내용이 없다면 3초 뒤에 바로 실행이 되겠지만 만일 다른 작업이 존재한다면, 3초가 넘어가서 실행되게 된다. `setTimeout()`이라는 함수는 n초 뒤에 콜백을 단순히 큐에 넣는 게 끝이다. 

**큐에 들어간 콜백 함수는 이벤트 루프가 스택으로 넣어 실행된다.** 코드를 간단히 보자면 아래와 같다.

```js
var eventLoop = [];
var event;

while(true) {
    // 틱!
    if (eventLoop.length > 0) {
        event = eventLoop.shift();
    }
    try {
        event(); // 호출스택으로 밀어넣는다
    }
    catch(err) {
        //...
    }
}
```

큐에 이미 대기번호가 100개가 있다면 foo는 101번째 대기표를 받게 되는 것이다. 따라서 `setTimeout()`은 지정한 시간동안은 실행되지 않는 것은 보장할 수 있지만 지정한 시간에 실행되는것은 보장할 수 없는 것이다.