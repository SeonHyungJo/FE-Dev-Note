# 웹 브라우저 작동 원리

## Rendering Engine(렌더링 엔진)

> Webkit Engine : Chrome(not Now), Safari

![Webkit](https://github.com/SeonHyungJo/FrontEnd-Dev/blob/master/assets/image/Webkit.png?raw=true)

> Gecko Engine : Firefox

![Gecko](https://github.com/SeonHyungJo/FrontEnd-Dev/blob/master/assets/image/Gecko.jpg?raw=true)

## Critical Rendering Path(주요 렌더링 과정)

> Rendering(렌더링) : 브라우저상의 화면을 그리는 행위

웹 브라우저가 화면을 그리는(Rendering) 주요한 과정

1. 서버에서 받아온 HTML데이터를 Parsing하여 **DOM Tree를 만든다**.
2. Parsing하는 도중 CSS링크를 만나게 되면, **CSSOM(CSS Object Model) Tree를 만든다**.
3. DOM Tree와 CSSOM Tree 2개를 합쳐서 **Render Tree를 만든다**.
4. [Layout] Render Tree 노드들의 위치를 계산한다(**Flow**).
5. 화면에 웹 페이지를 그린다(**Paint**).
6. Layer들을 합친다(**Composite**).


### HTML 데이터 Parsing / DOM Tree 생성

브라우저는 서버에서 받아온 HTML 데이터를 Parsing하여 DOM Tree를 만든다.

모든 HTML 태그에는 노드가 있고, 각각의 노드들은 Tree형태로 구현된다. 이는 **DOM Tree**라 불린다.

```html
<html>
    <head>
        <title>Dev_sseon</title>
    </head>
    <body>
        <div>
            <button> up </button>
            middle
            <button> down </button>
        </div>
    </body>
</html>
```

### CSSOM Tree 생성

HTML Parsing 중 CSS 링크(`<link>`)를 만나게 되면 서버에서 Resource를 요청한다. 받아온 파일은 Parsing되고 CSSOM Tree를 만든다.

CSSOM이 구성되어야 다음과정이 진행된다.(**Rendering의 Blocking 요소**)

> 위의 사진에서도 DOM Tree와 CSSOM Tree가 만들어져야 다음 단계가 이루어지는 것을 볼 수 있다. 해당 과정이 오래걸리게 되면 화면을 그리는데 완료되는 시간이 늦춰진다.

### Render Tree 생성

DOM Tree와 CSSOM Tree를 결합하여, **Render Tree**를 만든다.

**Render Tree는 DOM Tree에 있는 것들 중에 실제 보이는 것들로만 구성된다.**

> 즉, Ex) `style='display : none;'` 같은 화면에서 보이지 않는 것들은 Render Tree에서 제외된다. Header에 있는 메타태그도 제외대상이다.

Render Tree에는 Render Object Tree, Render Layer Tree, Render Style Tree, InlineBox Tree 등이 포함된다.

Render Object의 필요에 따라 **Render Layer**가 만들어지고 GPU 처리 여부에 따라 **Graphic Layer(하드웨어 가속)** 생성한다.

> 차후 하드웨어 가속에 관련된 글을 적도록 하겠습니다.

![graphic layer](/assets/image/graphicLayer.png?raw=true)

기본적으로 Layer는 하나이며, CPU가 렌더링에 주요한 역할을 한다. 그러나 아래와 같은 경우에 있어서는 GPU를 사용하게 된다. 이러한 방식으로 강제로 GPU를 사용하게 하여 성능을 높일 수 있다.

- CSS 3D Transform(translate3d, preserve-3d 등)이나 perspective 속성이 적용된 경우
- CSS 애니메이션함수나 필터함수를 사용하는 경우
- video나 canvas 요소를 사용하는 경우
- 자식 요소가 레이어로 구성된 경우
- z-index가 낮은 형제 요소가 레이어로 구성된 경우
- will-change 요소가 있는 경우

### Layout(Flow)

Render Tree가 만들어지고, **각각의 노드들의 위치를 계산하는 과정이다.**
위치 관련된 속성 계산한다(position, width, height 등등).

**ex) width:100%인 상태에서 브라우저를 리사이즈하면, Render Tree는 변경되지 않고 Layout 이후 과정만 다시 거치게 된다.** (Reflow => Repaint)

### Paint

실제 웹페이지를 화면에 그리는 작업이다.

**색이 바뀐다거나 노드의 스타일이 바뀌는 걸로는 Layout 과정을 거치지 않고 Paint만 일어난다.**

## HTML상에서 CSS와 JavaScript의 위치는 어디가 적절할까?

브라우저의 Redering 과정에서 DOM Tree를 만든 후, 스타일 규칙이 없으면 Rendering이 불가능하다.

인터프리터은 HTML을 위에서 아래로 읽기 때문에 CSS를 `<head></head>` 태그 사이에 두면 CSS 리소스를 최대한 빨리 받아올 수 있다.

반면, JavaScript는 DOM객체를 컨트롤하기 때문에 CSS처럼 위에 두게 되면 Parsing을 멈추고 Script를 읽기 때문에 성능이 저하된다. 따라서, JavaScript 소스는 주로 `</body>` 태그 아래에 모아두는게 좋다.

단, 이런 경우 JS 애니메이션이 나중에 적용되어 사용자 입장에서 깜빡임 현상이 생길 수 있기 때문에 애니메이션 부분만 위쪽에 두는 것도 방법이다.

### Composite

예전 브라우저에서는 없던 항목이었으나 브라우저가 발전함에 따라 생긴 과정이다. 

위에 언급한 GPU를 이용한 layer를 여러 개로 나뉘게 되는데 각각의 layer들은 Layout, Paint과정을 거친 후 만들어진 layer들을 합치는 과정을 Composite이라고 한다.

여러 layer로 그렸기때문에 병렬처리가 가능하며 렌더링 속도를 높이는데 기여한다.

---

#### Reference

- [Naver D2 - 브라우저의 작동 원리](http://d2.naver.com/helloworld/59361)
- [브라우저가 웹페이지를 그리는 법](https://isme2n.github.io/devlog/2017/07/06/browser-rendering/)
- [웹브라우저에서 HTML문서 렌더링 과정](http://jeong-pro.tistory.com/90)